package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"

	"webapp-cve-consumer/pkg/cve"
	"webapp-cve-consumer/pkg/db"

	"github.com/Shopify/sarama"
)

func main() {
	brokers := []string{"localhost:9092"} // Update with your Kafka brokers
	topic := "cve"                        // Update with your Kafka topic

	database, err := db.Connect()
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer database.Close()

	// Create database schema
	err = db.CreateSchema(database)
	if err != nil {
		log.Fatalf("Failed to create schema: %v", err)
	}

	config := sarama.NewConfig()
	config.Consumer.Return.Errors = true

	// Create new consumer
	master, err := sarama.NewConsumer(brokers, config)
	if err != nil {
		log.Fatalf("Error creating consumer: %s", err)
	}
	defer master.Close()

	// Create a channel to handle OS signals
	signals := make(chan os.Signal, 1)
	signal.Notify(signals, syscall.SIGINT, syscall.SIGTERM)

	doneCh := make(chan struct{})

	// Function to consume messages from a specific partition
	consumePartition := func(partition int32) {
		consumer, err := master.ConsumePartition(topic, partition, sarama.OffsetOldest)
		if err != nil {
			log.Fatalf("Error creating partition consumer: %s", err)
		}
		defer consumer.Close()
		log.Printf("Consumer for partition %d started\n", partition)
		for {
			select {
			case err := <-consumer.Errors():
				log.Printf("Error: %s", err)
			case msg := <-consumer.Messages():
				var message cve.CVERecord
				log.Printf("Received message from partition %d: %s\n", partition, string(msg.Value))
				if err := json.Unmarshal(msg.Value, &message); err != nil {
					log.Printf("Error unmarshaling message: %s", err)
				} else {
					fmt.Printf("Received message from partition %d: %+v\n", partition, message)
					// Store the message in the database
					err = db.StoreCVERecord(database, message)
					if err != nil {
						log.Printf("Failed to store CVE record: %v", err)
					}
				}
			case <-signals:
				fmt.Printf("Interrupt detected for partition %d\n", partition)
				doneCh <- struct{}{}
				return
			}
		}
	}

	// Start a goroutine for each partition
	for partition := int32(1); partition < 4; partition++ {
		log.Printf("Starting consumer for partition %d\n", partition)
		go consumePartition(partition)
	}

	<-doneCh
	fmt.Println("Consumer closed")
}
